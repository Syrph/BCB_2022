---
title: ''
permalink: /Practical_3/
excerpt: ''
output:
  word_document: default
  pdf_document: default
redirect_from: /theme-setup/
layout: single
classes: wide
sidebar:
  nav: docs
last_modified_at: '2020-07-27'
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=7, dpi=300)
```


## Setting conservation priorities

### 1. Introduction and resources

This practical is aimed to introduce you to the EDGE & EcoEDGE scores that you'll need for your conservation strategy coursework. Put briefly, these scores balance the distinctiveness of species against their risk of extinction to determine conservation priorities. You can find out more information about EDGE scores from the ZSL website:

<https://www.zsl.org/conservation/our-priorities/wildlife-back-from-the-brink/animals-on-the-edge>

We will also try plotting a simple map of IUCN categories so we can visual the risk to our clade across the globe.

### 2. Preparing data

To calculate EDGE metrics, we need data on the species we're interested in, and their phylogenetic relationship. For the coursework we're interested in EDGE scores for a specific clade, however it's also common to look at areas such as national parks.

For this practical we're going to use the same family as Practical 2, Accipitridae. We'll use the same table of traits from Practical 2 to import our data and filter it.

```{R}
# Read in the avonet data again.
trait_data <- read.csv("data/avonet_data.csv")
str(trait_data)
```

And again filter for Accipitridae.

```{R}
# Load dplyr so we can filter.
library(dplyr)
accip_data <- trait_data %>% filter(jetz_family == "Accipitridae")
```


Because we're going to use EDGE scores, we should check for any extinct species we need to remove.

```{R}
# This operator | means OR. EW means extinct in the wild.
accip_data %>% filter(redlist_cat == "EX" | redlist_cat == "EW")
```

Great, no extinct species in this family! There shouldn't really be many in our Jetz phylogeny, but some do turn up occasionally.

Now we need to load in our tree. For this practical we're using a random tree extracted from <http://birdtree.org/>

Because we're not sure on the exact placement of some species tips, the Jetz tree has multiple versions, each with a slightly different layout. Normally this only means a few species have swapped places slightly. This is why we've chosen a random tree for our analysis. There are other methods for dealing with this uncertainty, but for these practicals it will be enough to use a random tree. 

```{R}
# Load phylogenetic packages.
library(ape)
library(caper)

# Load in and plot the tree.
bird_tree <- read.tree("data/all_birds.tre")
plot(bird_tree, cex=0.01)
```

There's a lot of tips so that's a pretty ugly tree! We can remove the species as we did before.
See if you can do it yourself first using drop.tips again.



::::{admonition} Show the answer...    
:class: dropdown

```{r}
# Get the tips we don't want.
drop_tips <- setdiff(bird_tree$tip.label, accip_data$jetz_name)

# Drop the tips.
bird_tree <- drop.tip(bird_tree, drop_tips)
```


::::



### 3. ED Scores

Now that we've got our tree and our species we can start calculating our ED (Evolutionary Distinctiveness) scores. Then we can figure out if specific Accipitridae species are closely related to others in the tree, or represent distinct lineages that might want to conserve to protect valuable evolutionary diversity.

We can do this easily using a simple function from the `caper` package. This sometimes takes a while to run.

```{R}
# We first transform our tree into a matrix of distances from each tip to tip. 
# This step is optional but stops a warning from ed.calc, which prefers a matrix.
bird_matrix <- clade.matrix(bird_tree)

# Now we can run the ed.calc function, which calculates ED scores for each species. 
# The output gives two dataframes, but we only want the species names and scores so we use $spp
ED <- ed.calc(bird_matrix)$spp
head(ED)
```

Now that we've got our ED scores for each species, we need to log transform and normalise our scores.

```{R}
# By adding 1 to our scores, this prevents negative logs when our ED scores are below 1.
ED$EDlog <- log(1+ED$ED)

# We can normalise our scores so they're scaled between 0 and 1.
ED$EDn <- (ED$EDlog - min(ED$EDlog)) / (max(ED$EDlog) - min(ED$EDlog))
head(ED)
```


We now have the ED scores of 237 species in Accipitridae. With these scores we can see how unique our species are in terms of the evolutionary pathway.

```{R}
# Find the highest ED score.
ED[ED$EDn == max(ED$EDn),]
```

The highest ED scores belong to *Chelictinia riocourii*,  the scissor-tailed kite, and *Gampsonyx swainsonii*, the pearl kite. Both species are the only member of a monotypic genus, and part of the small subfamily Elaninae, the elanine kites. This subfamily only has six species, and all the others form one genus. Therefore, with so few close relatives, we might consider this species a conservation priority to protect as much diversity as we can. However we don't yet know if this species needs conserving...

### 4. EDGE Scores

This is where EDGE scores come in. By combining ED scores with IUCN categories we can select the species that need conservation action, and represent unique evolutionary variation.

Each IUCN category has an extinction probability used to calculate EDGE scores. For these practicals we'll use the extinction probabilities suggested by Mooers *et al.* (2008), looking at a 50 year time frame. Here's the link to the publication, which you should cite in your reports.

<https://doi.org/10.1371/journal.pone.0003700.t001>

These extinction probabilities are also referred to as GE (Globally Endangered) scores, which is why it's called EDGE. We'll add the ED scores to the main dataset first, and then we can easily calculate EDGE.


```{R}
# Join the last two columns of UK_Jetz to ED scores. 
# This time we'll use the 'by' argument rather than change the column names.
accip_EDGE <- left_join(accip_data, ED,  by = c("jetz_name" = "species"))

# Head but we'll view just the first and last few columns.
head(accip_EDGE)[,c(2:3, 26:29)]
```

We can now calculate our EDGE scores using some simple maths:

```{math}
EDGE=ln⁡(1+ED)+GE×ln⁡(2)
```


We have already done the first half. Now we just need to multiply GE scores by the natural log of 2, and combine them.

```{R}
# The log function uses natural logarithms by default.
accip_EDGE$EDGE <- accip_EDGE$EDlog + accip_EDGE$extinct_prob * log(2)
head(accip_EDGE)[,c(2:3, 26:30)]
```

Now we have our EDGE scores, we can see if our conservation priority has changed in light of IUCN categories.

```{R}
# Find the highest EDGE score.
accip_EDGE[accip_EDGE$EDGE == max(accip_EDGE$EDGE), c(2:3, 26:30)]

# Find the EDGE score for our previous highest species.
accip_EDGE[accip_EDGE$EDn == max(accip_EDGE$EDn), c(2:3, 26:30)]
```


So now we can see that the top conservation priority is the Philippine Eagle, *Pithecophaga jefferyi*. Whilst our previous kites are still high, their low IUCN score means its less of a priority than P. jefferyi, which is critically endangered.

In reality, you want to preserve more than just one species! We can see from the spread of EDGE scores that there are few species with high EDGE scores, and we would ideally like to create a plan that maximises the conservation of all of them (if it's possible). Based on your own taxa you'll decide what constitutes a high EDGE score.

```{R}
# Plot a histogram of EDGE values.
hist(accip_EDGE$EDGE, breaks = 20)
```



```{R}
# WE can use the select function to pull out only the columns we want to view.
# Because there's another function called select, we specify it's from dplyr.
accip_EDGE %>% filter(EDGE > 3) %>% dplyr::select(birdlife_common_name, jetz_name, redlist_cat, EDGE)
```

```{tip}
In the above code we used the pipe operator `%>%` twice! This is why it's called a pipe. 
We can get the end product of each function to "flow" down to the next, like water 
down a pipe! 
```
### 5. EcoDGE Scores

Instead of evolutionary distinctiveness, we might instead be interested in what functions each species provides the ecosystem. Species with low functional distinctiveness may be 'functionally redundant' in the ecosystem, whereas those with high functional distinctiveness may provide key ecosystem services that aren't easily replaceable. We call these scores EcoDGE scores, with "eco" short for ecologically diverse.

Like ED, we will calculate functional distinctiveness (FD and FDn) in relation to all other accipitridae species. The reason for this is that FD is traditionally used in the context of a specific community or radiation of species (i.e. all birds found within a national park, or all species of lemur).

To calculate the function of species, we'll use their morphological traits. Recent research (Pigot *et al.* 2020) has shown that a few simple traits can predict the niche a species occupies, which in turn tells us about function. For instance, frugivores provide vital seed dispersal, and insectivores influence invertebrate population dynamics.

You can read the full article here:
<https://www.nature.com/articles/s41559-019-1070-4>

We'll use just a few key traits, separated into beak traits (primarily trophic), body traits (primarily locomotion), and body mass. 

```{R}
# Split the traits into beak shape traits, body shape traits, and body mass.
beak_traits <- accip_data %>% dplyr::select(beak_length_culmen, beak_width, beak_depth)
body_traits <- accip_data %>% dplyr::select(tarsus_length, wing_length, tail_length)
body_mass <- log(accip_data$mass)

# Look at the correlations between traits, including body mass.
pairs(cbind(beak_traits, body_mass))
pairs(cbind(body_traits, body_mass))
```

So we can see some pretty strong correlations between beak shape, body shape and body mass. This is because bigger species tend to have proportionally bigger traits. If we were to calculate functional distinctiveness using these traits in their current form, we would probably only determine which species are the biggest and smallest. Another problem is that when all the traits are highly correlated, it's harder to tell which ones are important for functional distinctiveness. Instead our model may simply pick them at random, leading to potentially random results.

Instead we can use two variables from Pigot et al. 2020, "beak shape", and "body shape". These variables were created using a Principal Components Analysis (PCA) to condense our traits down into fewer uncorrelated variables, removing body mass as the dominant effect. 

```{tip}
We won't go into much detail on how a PCA works, as we want to focus on understanding the role of functional distinctivness in conservation. If you'd like to know in more detail, StatQuest has a great 5 minute [video](https://www.youtube.com/watch?v=HMOI_lkzW08&ab_channel=StatQuestwithJoshStarmer).
```



```{R}
# First standardize the traits so they're all on a similar scale.
beak_traits <- scale(beak_traits)
body_traits <- scale(body_traits)

# Run a PCA of each set of traits separately.
beak_pca <- princomp(beak_traits)
body_pca <- princomp(body_traits)

# Look at the variation explained by each axes.
summary(beak_pca)
summary(body_pca)
```

Running `princomp` has created a PCA object, with three uncorrelated axes. They are arranged in order of the variation they explain, with the 1st component (PC1) explaining the most. We can see this is 95% of the variation for beak traits, and 83% of the variation for body shape traits. 

We can look at the loadings of each PCA object to see how the original variables contributed to each new PCA axis.

```{R}
# Return the loadings.
loadings(beak_pca)
loadings(body_pca)
```

We can see that for the first component, all three traits are positively correlated at roughly equal amount (+0.58). So species with longer, wider and deeper beaks have a higher PC1 value. The same is true for body shape. So PC1 most likely maps onto body size. We can test this by plotting them together.


```{R}
# Plot PC1 against mass.
par(mfrow = c(1,2))
plot(beak_pca$scores[,1] ~ body_mass)
plot(body_pca$scores[,1] ~ body_mass)
```

Looking at the 2nd component (PC2), we can see from the loadings that it describes different shapes. In beak we can see a strong positive correlation with beak length, and negative correlations with width and depth. So species with a high PC2 tend to have long narrow beaks, rather than short fat ones. For body shape, PC2 describes the ratio of tail to tarsus length. So species with a low PC2 will have shorter legs compared to tails, and are more agile hunters. 

Both PC2 axes describe aspects of morphology that tell us about the species function better than just total size. We can now use this information to determine the functional diversity of accipitridae. 

To calculate functional diversity we'll create a distance matrix of our traits. Species with similar traits will have smaller 'distances'.

```{R}
# Create a matrix. Add in the rownames for the species.
traits_matrix <- cbind(beak_pca$scores[,2], body_pca$scores[,2], scale(log(accip_data$mass)))
rownames(traits_matrix) <- accip_data$jetz_name

# Converts traits into 'distance' in trait space.
distance_matrix <- dist(traits_matrix)
```

The next step is to create a new tree using the neighbour-joining method (Saitou & Nei, 1987) (Google for more information!). This will create a tree where branch lengths show how similar species are in trait space rather than evolutionary distance. This function may take a while with more species so don't be alarmed if the group you've chosen takes much longer.

```{R}
# Create the tree.
trait_tree <- nj(distance_matrix)

# Test to see if it's worked. The tree looks different to a normal one because tips 
# don't line up neatly at the present time period like with evolutionary relationships.
plot(trait_tree, cex=0.4)
```


FD trees can fail if there are too many NAs in the data. If this is the case for your taxa, remove species or traits with high NA counts from FD analysis. Note, however, that the bird data is very complete so there should be no need to remove NA species from the dataset; this should be a last resort so only do this if the analyses are failing repeatedly.

With our tree of functional space, we can now calculate FD scores the same way we calculated ED scores.

```{R}
# Create a matrix of distance from tip to tip.
tree_matrix <- clade.matrix(trait_tree)

# Calculate FD scores.
FD <- ed.calc(tree_matrix)$spp

# Change the name to FD.
colnames(FD)[2] <- "FD"
head(FD)
```

Log and normalise the data as we did before with ED so we could compare FD scores from different groups.

```{R}
# Calculate the scores again.
FD$FDlog <- log(1+FD$FD)
FD$FDn <- (FD$FDlog - min(FD$FDlog)) / (max(FD$FDlog) - min(FD$FDlog))

# Find the highest FD score.
FD[FD$FDn == max(FD$FDn),]
```


So the species with the largest FD score is *Gypaetus barbatus*, the Bearded Vulture. 
This means *G. barbatus* is the most ecologically diverse species in our clade, based
on the morphological values we've supplied. You might be interested to know that 
*G. barbatus* is a very unique vulture, with long narrow wings, and wedge shaped tail
that makes it unmistakable in flight! Moreover, they live on a diet of up to 90% 
bone marrow, which makes them the only living bird that specialises on marrow! This 
will be reflected in the beak morphological traits we used to calculate FD. Pretty 
cool right!

We can also look at the top 5% of functionally distinct species.
 
```{R}
# Get the top 5% of FD scores.
FD[FD$FD > quantile(FD$FD, 0.95),]
```

So these are the most functionally distinct species in our dataset, each providing an ecosystem role that is not easily replaceable. However, most of these species don't currently face high extinction risk. We should therefore combine GE scores to see how IUCN categories change our priorities. We use the same formula as before:

```{math}
ecoDGE=ln⁡(1+FD)+GE×ln⁡(2)
```

```{R}
# Join FD and GE scores.
accip_ecoDGE <- left_join(accip_data, FD, by = c("jetz_name" = "species"))

# Calculate ecoDGE scores.
accip_ecoDGE$ecoDGE <- accip_ecoDGE$FDlog + accip_ecoDGE$extinct_prob * log(2)
head(accip_ecoDGE)[,c(2:3, 6, 27:30)]
```

And does including IUCN categories change our conservation priorities?

```{R}
# Find the highest ecoDGE score.
accip_ecoDGE[accip_ecoDGE$ecoDGE == max(accip_ecoDGE$ecoDGE), c(2:3, 6, 27:30)]
```


```{R}
# Find the ecoDGE score for Gypaetus barbatus.
accip_ecoDGE[accip_ecoDGE$jetz_name == "Gypaetus_barbatus", c(2:3, 6, 27:30)]
```


Yes! The Hooded Vulture is now our top conservation priority if we use ecoDGE scores to inform our decisions. We can also look at the top species.


```{R}
# Get the top 5% of ecoDGE scores.
accip_ecoDGE[accip_ecoDGE$ecoDGE > quantile(accip_ecoDGE$ecoDGE, 0.95), c(2:3, 6, 27:30)]
```




As we can see, nearly all of the highest ecoDGE scores are critically endangered, which means we could soon lose their unique ecosystem functions. The removal of enough of these species may even cause a collapse in the current ecosystem, as species are unable to fill vital niches. But is it right to focus on these species instead of our top EDGE species? Could you argue a case for EDGE or ecoDGE as the top priority of conservation? 



### 6. EcoEDGE Scores


So we've used EDGE scores to combine extinction risk with evolutionary distinctiveness, and ecoDGE scores to do the same with functional distinctiveness, However, both are important, and we might want to combine all three into one metric. This is exactly what EcoEDGE scores do (confusingly, their creators decided to use very very similar names). And we've pretty much done all the hard work already. The equation is similar to the ones we've used, but we give ED and FD scores equal weighting:

```{math}
EcoEDGE= (0.5×EDn + 0.5×FDn) + GE×ln⁡(2)
```
And remember our EDn and FDn scores have already been logged, so we don't need to log them now.

```{R}
# Merge FD and ED scores.
accip_EcoEDGE <- left_join(accip_EDGE, accip_ecoDGE)

# Calculate EcoEDGE scores.
accip_EcoEDGE$EcoEDGE <- (0.5*accip_EcoEDGE$EDn + 0.5*accip_EcoEDGE$FDn) + accip_EcoEDGE$extinct_prob*log(2)

# Select just the relevant columns.
accip_EcoEDGE <- accip_EcoEDGE %>% dplyr::select(birdlife_common_name, jetz_name, 
                                                 redlist_cat, extinct_prob, EDGE, ecoDGE, EcoEDGE)

# Check it's worked.
head(accip_EcoEDGE)
```


We can again look at the spread and see which are the highest species.

```{R}
# Get the highest scoring species.
accip_EcoEDGE[accip_EcoEDGE$EcoEDGE == max(accip_EcoEDGE$EcoEDGE),]

# Get the top 10% of EcoEDGE scores.
accip_EcoEDGE[accip_EcoEDGE$EcoEDGE > quantile(accip_EcoEDGE$EcoEDGE, 0.9),]

# See the spread.
hist(accip_EcoEDGE$EcoEDGE, breaks = 20)
```



So when combining EDGE and ecoDGE, the Philippine Eagle is the highest species. In general, we might expect ED and FD to correlate, as species with many close relatives are likely to share morphological traits that determine function. For your own taxa, you might find that these scores match up, or perhaps there are different conservation priorities for each metric. Because we don't tend to focus on conserving a single species, there should be differences between each metric that make deciding conservation priorities a complicated task. How you chose to interpret and present your results is up to you, and will depend on the group that you've chosen.

For the practicals and coursework we've chosen to use a simplified version of EcoEDGE scores. If you're interested in learning more, check out this paper which first proposed the use of EcoEDGE scores:

<https://onlinelibrary.wiley.com/doi/full/10.1111/ddi.12320>

```{tip}
For your coursework, you should cite both the original [EDGE reference](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0000296), as well as the [EcoEDGE reference](https://onlinelibrary.wiley.com/doi/full/10.1111/ddi.12320).

In general, most of the papers linked in this practical will be useful citations you should think about including.
```

### 7. Plotting a map of IUCN categories

You may wish to plot maps of your IUCN redlist categories, especially if you're interested in what areas of the world are most threatened by extinction. We can do this easily using similar code from practical 2.

```{R}
# First load in the spatial packages we'll need.
library(raster)
library(sf)
library(fasterize)

# Load the data into our environment.
load("data/accipitridae_ranges.RData")

# Inspect the maps.
class(accip_ranges)
head(accip_ranges)
```

We'll run the same code as before to compile our spatial dataframe into a single raster layer. The only difference is this time we're assigning values based on GE rating rather than range size.


```{R}
# Combine the two datasets into one object. (This turns our maps into a normal dataframe)
accip_ranges <- left_join(accip_EcoEDGE, accip_ranges, by = c("jetz_name" = "SCINAME"))

# Create an empty raster stack to store our data in.
raster_template <- raster(ncols=2160, nrows = 900, ymn = -60)

# 'fasterize' needs objects to be an sf class so we'll convert it back into an sf dataframe.
accip_ranges <- st_sf(accip_ranges)

# Use the fasterize function with the raster template. 
# We want to use the GE field, and the function max takes the highest value when they overlap.
GE_raster <- fasterize(accip_ranges, raster_template, field = "extinct_prob", fun = "max")

# Plot the new map. Colour ramp palette is another way to make a palette.
# The second brackets (50) is the number of colours to create from the function.
green_to_red <- colorRampPalette(c("forestgreen", "khaki", "firebrick"))(20)
plot(as.factor(GE_raster), col=green_to_red)
```

```{tip}
You can use `colors()` to see the list of all the named colours to play with.
```

Now we've created our stack of range maps, and each are coded for their IUCN category. In this case we'll take the maximum GE score as the one that's shown. So if two ranges overlap, we take the highest score.

So now you can see the spread of GE scores throughout the globe. For your own species you may wish to focus on a specific area of Earth using the `crop()` function. Again we'll use ggplot2 to make them a little nicer to look at.

```{R}
library(tidyr)
library(ggplot2)

# Convert the raster into a raster dataframe. 
# Remove rows with NA values from this dataframe.
raster_data <- as.data.frame(GE_raster, xy=TRUE) %>% drop_na()
colnames(raster_data) <- c("long", "lat", "index")

# Turn the GE score values to a factor to give a discrete raster rather than continuous values.
raster_data$index <- as.factor(raster_data$index)

# we can then plot this in ggplot. We have to first create the colour scheme for our map.
# The six character codes (hexcodes) signify a colour. There are many stock colours 
# (i.e. "grey80" yellow" "orange" "red") but hexcodes give more flexibility.
# Find colour hexcodes here: https://www.rapidtables.com/web/color/RGB_Color.html
myColors <- c("grey80", "grey80", "#FCF7B7", "#FFD384", "#FFA9A9")

# Assign names to these colours that correspond to each GE score. 
# We also use the sort() function to make sure the numbers are in ascending order.
names(myColors) <- unique(sort(raster_data$index))

# Create the colour scale.
colScale <- scale_fill_manual(name = "Extinction\nProbability", values = myColors)

# Create a plot with ggplot (the plus signs at the end of a line carry over to the next line).
GE_plot <- ggplot() +
  
  # Add the borders again.
  borders(ylim = c(-60,90), fill = "grey90", colour = "grey90") +
  
  # We need to reset the xlim to -180/180 again.
  xlim(-180, 180) +

  # Add the GE information on top.
  geom_tile(aes(x = long, y = lat, fill = index), data = raster_data) +
  
  # Add the formatting again!
  colScale +
  ggtitle("Accipitridae Threat Map") +
  theme_classic() +
  ylab("Latitude") +
  xlab("Longitude") + 
  coord_fixed()

# Resize the plotting window and return the plot so we can view it.
options(repr.plot.width=15, repr.plot.height=10)
GE_plot
```

There's our finished map! Think how you'd change it yourself if you want to include one in your report. It's up to you and what you think is the best way to visualise your data!  


> Extra task: Do you think this is a good way to show the data? What would you do differently? Could you use another metric from today's practical like EDGE? And is taking the highest score when cells overlap the best option? Instead try and create an average extinction probability raster.

```{tip}
Fasterize doesn't have a mean function option, but we can get around this by dividing one raster by another. 
We first need to sum all the extinction probabilities, and then divide by species richness. Look back at 
[Practical 1](https://syrph.github.io/BCB_2022/markdowns/practical_1/practical_1.html#plotting-maps) for a reminder of how to create a species richness raster. Then it's as easy as:
  
  `average_raster <- sum_raster / richness_raster`
  

```

::::{admonition} Show the answer...    
:class: dropdown

```{R}
# Sum all the extinction probabilities.
sum_raster <- fasterize(accip_ranges, raster_template, field = "extinct_prob", fun = "sum")

# Use the sum function with no field for richness. (Assumes each range = 1).
richness_raster <- fasterize(accip_ranges, raster_template, fun = "sum")

# Divide the total by number of species to get average.
average_raster <- sum_raster / richness_raster

# Plot the new map.
plot(average_raster)
```

In this case we can see that the two maps are actually quite similar. 
If we look close enough we can see there are some cells that have a higher extinction
risk (like in southern Spain), but there are so few we'd probably call them outliers.
This stretches out our colour scale, and makes it hard to determine relative patterns 
for the rest of the world. We can instead take logs, which reduces the effect of outliers. 

```{R}
# Plot the map after logging cell values.
plot(log(average_raster), col = green_to_red)
```

Now we can see the pattern clearer. For your coursework, experiment with different metrics and methods
to produce the best looking and most informative maps. Lastly we can redo the maps with ggplot, and rescale
the values so that it's relative extinction risk (not probability).

```{R}

# With GGplot. 
raster_data <- as.data.frame(average_raster, xy=TRUE) %>% drop_na()
colnames(raster_data) <- c("long", "lat", "index")

# We'll log the values, and then rescale from 0 to 1 so it's relative probabilities.
raster_data$index <- log(raster_data$index)
raster_data$index <- (raster_data$index - min(raster_data$index)) / (max(raster_data$index) - min(raster_data$index))

ggplot() +
  
  # Add the borders again.
  borders(ylim = c(-60,90), fill = "grey90", colour = "grey90") +
  xlim(-180, 180) +

  # Add the GE information on top.
  geom_tile(aes(x = long, y = lat, fill = index), data = raster_data) +
  
  # Add the formatting again!
  # Add a continuous colour scheme in ggplot.
  scale_fill_gradientn(colours = green_to_red, name = "Relative\nExtinction\nRisk") +
  ggtitle("Accipitridae Threat Map") +
  theme_classic() +
  ylab("Latitude") +
  xlab("Longitude") + 
  coord_fixed()

```

::::
